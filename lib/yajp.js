// Generated by CoffeeScript 1.7.1
var YAJP,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

YAJP = {
  OPEN_BRACKET: '[',
  CLOSE_BRACKET: ']',
  OPEN_PAREN: '{',
  CLOSE_PAREN: '}',
  DOUBLE_QUOTE: '"',
  SINGLE_QUOTE: "'",
  COLON_TOKEN: ':',
  COMMA_TOKEN: ',',
  PERIOD_TOKEN: '.',
  MINUS_TOKEN: '-',
  symbols: ['[', ']', '{', '}', '"', "'", ':', ',', ".", "-"],
  spaces: [' ', '\n', '\r', '\t'],
  separators: ['}', ']', ',', ':'],
  TRUE_IDENTIFIER: 'true',
  FALSE_IDENTIFIER: 'false',
  NULL_IDENTIFIER: 'null',
  TOKEN_TYPE_SYMBOL: 'SYMBOL',
  TOKEN_TYPE_STRING: 'STRING',
  TOKEN_TYPE_NUMBER: 'NUMBER',
  TOKEN_TYPE_BOOL: 'BOOL',
  TOKEN_TYPE_NULL: 'NULL',
  Token: function(val, type) {
    return {
      "val": val,
      "type": type
    };
  },
  isSpace: function(c) {
    return __indexOf.call(this.spaces, c) >= 0;
  },
  isSeparator: function(c) {
    return __indexOf.call(this.separators, c) >= 0;
  },
  isIdentifier: function(c) {
    return !!c.match(/[a-z]/);
  },
  isNumber: function(c) {
    return !!c.match(/[0-9]/);
  },
  isSymbol: function(c) {
    return __indexOf.call(this.symbols, c) >= 0;
  },
  isQuote: function(c) {
    return c === this.DOUBLE_QUOTE || c === this.SINGLE_QUOTE;
  },
  isNumberComponent: function(c) {
    return (c === this.MINUS_TOKEN || c === this.PERIOD_TOKEN) || this.isNumber(c);
  },
  isValueToken: function(tok) {
    var _ref;
    return (_ref = tok.type) === this.TOKEN_TYPE_STRING || _ref === this.TOKEN_TYPE_BOOL || _ref === this.TOKEN_TYPE_NUMBER || _ref === this.TOKEN_TYPE_NULL;
  },
  isSymbolToken: function(tok) {
    return tok.type === this.TOKEN_TYPE_SYMBOL;
  },
  nextChar: function() {
    if (this.location < this.jsonstr.length) {
      return this.jsonstr.charAt(++this.location);
    } else {
      throw new Error("out of range");
    }
  },
  nextValidChar: function() {
    var c;
    while (true) {
      if (!this.isSpace((c = this.nextChar()))) {
        return c;
      }
    }
  },
  backStep: function() {
    return --this.location;
  },
  nextIdentifier: function() {
    var c, id;
    id = "";
    while (true) {
      c = this.nextValidChar();
      if (this.isSeparator(c) || !c) {
        this.backStep();
        return id;
      } else if (!this.isIdentifier(c)) {
        throw new Error("expected identifier but " + c);
      } else {
        id += c;
      }
    }
  },
  nextString: function() {
    var c, str;
    str = "";
    while (true) {
      if (this.isQuote((c = this.nextChar()))) {
        return str;
      } else {
        str += c;
      }
    }
  },
  nextNumber: function() {
    var c, num;
    num = "";
    while (true) {
      c = this.nextValidChar();
      if (this.isSeparator(c) || !c) {
        this.backStep();
        return num;
      } else if (!this.isNumberComponent(c)) {
        throw new Error("expected number but " + c);
      } else {
        num += c;
      }
    }
  },
  nextToken: function() {
    var c, id;
    c = this.nextValidChar();
    if (this.isNumberComponent(c)) {
      return this.Token(Number(c + this.nextNumber()), this.TOKEN_TYPE_NUMBER);
    } else if (this.isQuote(c)) {
      return this.Token(this.nextString(), this.TOKEN_TYPE_STRING);
    } else if (this.isSymbol(c)) {
      return this.Token(c, this.TOKEN_TYPE_SYMBOL);
    } else {
      if (this.isNumber(c)) {
        throw new Error("expected identifier");
      }
      switch ((id = c + this.nextIdentifier())) {
        case this.FALSE_IDENTIFIER:
          return this.Token(false, this.TOKEN_TYPE_BOOL);
        case this.TRUE_IDENTIFIER:
          return this.Token(true, this.TOKEN_TYPE_BOOL);
        case this.NULL_IDENTIFIER:
          return this.Token(null, this.TOKEN_TYPE_NULL);
        default:
          throw new Error("unexpected identifier '" + id + "'");
      }
    }
  },
  extractValue: function(tok) {
    if (this.isValueToken(tok)) {
      return tok.val;
    } else if (this.isSymbolToken(tok)) {
      switch (tok.val) {
        case this.OPEN_BRACKET:
          return this.nextArray();
        case this.OPEN_PAREN:
          return this.nextObject();
        default:
          throw new Error("expected { or [ but " + tok.val);
      }
    } else {
      throw new Error("unexpected token " + tok.val);
    }
  },
  nextObject: function() {
    var key, obj, tok;
    obj = {};
    while (true) {
      if ((tok = this.nextToken()).val === this.CLOSE_PAREN) {
        return obj;
      } else {
        if (tok.type !== this.TOKEN_TYPE_STRING) {
          throw new Error("expected string but " + tok.val);
        }
        key = tok.val;
        tok = this.nextToken();
        if (tok.val !== this.COLON_TOKEN) {
          throw new Error("expected : but " + tok.val);
        }
        obj[key] = this.extractValue(this.nextToken());
        tok = this.nextToken();
        if (tok.val === this.CLOSE_PAREN) {
          return obj;
        }
        if (tok.val !== this.COMMA_TOKEN) {
          throw new Error("expected , but " + tok.val);
        }
      }
    }
  },
  nextArray: function() {
    var arr, tok;
    arr = [];
    while (true) {
      if ((tok = this.nextToken()).val === this.CLOSE_BRACKET) {
        return arr;
      } else {
        arr.push(this.extractValue(tok));
        tok = this.nextToken();
        if (tok.val === this.CLOSE_BRACKET) {
          return arr;
        }
        if (tok.val !== this.COMMA_TOKEN) {
          throw new Error("expected , but " + tok.val);
        }
      }
    }
  },
  parse: function(str) {
    this.jsonstr = str;
    this.location = -1;
    return this.extractValue(this.nextToken());
  }
};

module.exports = YAJP;
