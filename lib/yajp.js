// Generated by CoffeeScript 1.7.1
var YAJP,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

YAJP = {
  OPEN_BRACKET: '[',
  CLOSE_BRACKET: ']',
  OPEN_PAREN: '{',
  CLOSE_PAREN: '}',
  DOUBLE_QUOTE: '"',
  SINGLE_QUOTE: "'",
  COLON_TOKEN: ':',
  COMMA_TOKEN: ',',
  PERIOD_TOKEN: '.',
  MINUS_TOKEN: '-',
  NULL_CHARACTER: '\0',
  symbols: ['[', ']', '{', '}', '"', "'", ':', ',', ".", "-"],
  spaces: [' ', '\n', '\r', '\t'],
  separators: ['}', ']', ',', ':', '\0'],
  TRUE_IDENTIFIER: 'true',
  FALSE_IDENTIFIER: 'false',
  NULL_IDENTIFIER: 'null',
  TOKEN_TYPE_SYMBOL: 'SYMBOL',
  TOKEN_TYPE_STRING: 'STRING',
  TOKEN_TYPE_NUMBER: 'NUMBER',
  TOKEN_TYPE_BOOL: 'BOOL',
  TOKEN_TYPE_NULL: 'NULL',
  Token: function(val, type) {
    return {
      "val": val,
      "type": type
    };
  },
  Input: function(str) {
    return {
      "str": str,
      "loc": -1
    };
  },
  isSpace: function(c) {
    return __indexOf.call(this.spaces, c) >= 0;
  },
  isSeparator: function(c) {
    return __indexOf.call(this.separators, c) >= 0;
  },
  isIdentifier: function(c) {
    return !!c.match(/[a-z]/);
  },
  isNumber: function(c) {
    return !!c.match(/[0-9]/);
  },
  isSymbol: function(c) {
    return __indexOf.call(this.symbols, c) >= 0;
  },
  isQuote: function(c) {
    return c === this.DOUBLE_QUOTE || c === this.SINGLE_QUOTE;
  },
  isNumberComponent: function(c) {
    return (c === this.MINUS_TOKEN || c === this.PERIOD_TOKEN) || this.isNumber(c);
  },
  isValueToken: function(tok) {
    var _ref;
    return (_ref = tok.type) === this.TOKEN_TYPE_STRING || _ref === this.TOKEN_TYPE_BOOL || _ref === this.TOKEN_TYPE_NUMBER || _ref === this.TOKEN_TYPE_NULL;
  },
  isSymbolToken: function(tok) {
    return tok.type === this.TOKEN_TYPE_SYMBOL;
  },
  nextChar: function(input) {
    if (input.loc < input.str.length - 1) {
      return input.str.charAt(++input.loc);
    } else if (input.loc === input.str.length - 1) {
      return this.NULL_CHARACTER;
    } else {
      throw new Error("out of range");
    }
  },
  nextValidChar: function(input) {
    var c;
    while (true) {
      if (!this.isSpace((c = this.nextChar(input)))) {
        return c;
      }
    }
  },
  backStep: function(input) {
    return --input.loc;
  },
  nextIdentifier: function(input) {
    var c, id;
    id = "";
    while (true) {
      c = this.nextValidChar(input);
      if (this.isSeparator(c)) {
        this.backStep(input);
        return id;
      } else if (!this.isIdentifier(c)) {
        throw new Error("expected identifier but " + c);
      } else {
        id += c;
      }
    }
  },
  nextString: function(input) {
    var c, d, str;
    str = "";
    while (true) {
      if (this.isQuote((c = this.nextChar(input)))) {
        d = this.nextValidChar(input);
        this.backStep(input);
        if (this.isSeparator(d)) {
          return str;
        }
      } else {
        str += c;
      }
    }
  },
  nextNumber: function(input) {
    var c, num;
    num = "";
    while (true) {
      c = this.nextValidChar(input);
      if (this.isSeparator(c)) {
        this.backStep(input);
        return num;
      } else if (!this.isNumberComponent(c)) {
        throw new Error("expected number but " + c);
      } else {
        num += c;
      }
    }
  },
  nextToken: function(input) {
    var c, id;
    c = this.nextValidChar(input);
    if (this.isNumberComponent(c)) {
      return this.Token(Number(c + this.nextNumber(input)), this.TOKEN_TYPE_NUMBER);
    } else if (this.isQuote(c)) {
      return this.Token(this.nextString(input), this.TOKEN_TYPE_STRING);
    } else if (this.isSymbol(c)) {
      return this.Token(c, this.TOKEN_TYPE_SYMBOL);
    } else {
      if (this.isNumber(c)) {
        throw new Error("expected identifier");
      }
      switch ((id = c + this.nextIdentifier(input))) {
        case this.FALSE_IDENTIFIER:
          return this.Token(false, this.TOKEN_TYPE_BOOL);
        case this.TRUE_IDENTIFIER:
          return this.Token(true, this.TOKEN_TYPE_BOOL);
        case this.NULL_IDENTIFIER:
          return this.Token(null, this.TOKEN_TYPE_NULL);
        default:
          throw new Error("unexpected identifier '" + id + "'");
      }
    }
  },
  extractValue: function(input, tok) {
    if (this.isValueToken(tok)) {
      return tok.val;
    } else if (this.isSymbolToken(tok)) {
      switch (tok.val) {
        case this.OPEN_BRACKET:
          return this.nextArray(input);
        case this.OPEN_PAREN:
          return this.nextObject(input);
        default:
          throw new Error("expected { or [ but " + tok.val);
      }
    } else {
      throw new Error("unexpected token " + tok.val);
    }
  },
  nextObject: function(input) {
    var key, obj, tok;
    obj = {};
    while (true) {
      if ((tok = this.nextToken(input)).val === this.CLOSE_PAREN) {
        return obj;
      } else {
        if (tok.type !== this.TOKEN_TYPE_STRING) {
          throw new Error("expected string but " + tok.val);
        }
        key = tok.val;
        tok = this.nextToken(input);
        if (tok.val !== this.COLON_TOKEN) {
          throw new Error("expected : but " + tok.val);
        }
        obj[key] = this.extractValue(input, this.nextToken(input));
        tok = this.nextToken(input);
        if (tok.val === this.CLOSE_PAREN) {
          return obj;
        }
        if (tok.val !== this.COMMA_TOKEN) {
          throw new Error("expected , but " + tok.val);
        }
      }
    }
  },
  nextArray: function(input) {
    var arr, tok;
    arr = [];
    while (true) {
      if ((tok = this.nextToken(input)).val === this.CLOSE_BRACKET) {
        return arr;
      } else {
        arr.push(this.extractValue(input, tok));
        tok = this.nextToken(input);
        if (tok.val === this.CLOSE_BRACKET) {
          return arr;
        }
        if (tok.val !== this.COMMA_TOKEN) {
          throw new Error("expected , but " + tok.val);
        }
      }
    }
  },
  parse: function(str) {
    var input;
    input = this.Input(str);
    return this.extractValue(input, this.nextToken(input));
  }
};

module.exports = YAJP;
